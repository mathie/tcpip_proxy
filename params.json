{"name":"TCP/IP Proxy in Go","tagline":"Learning Go one refactoring at a time","body":"# TCP/IP Proxy in Go\r\n\r\n**TL;DR: I took some existing code and refactored it to the way I'd structure it.\r\nHowever, this is the first chunk of Go I've ever touched. Please submit pull\r\nrequests to turn it into idiomatic Go!**\r\n\r\nFor some reason, I was reading\r\n[The Beauty of Concurrency in Go](http://pragprog.com/magazines/2012-06/the-beauty-of-concurrency-in-go)\r\nyesterday morning and decided to spend 20 minutes typing out the code to see\r\nhow it felt in reality. I've been meaning to try Go for a while now, but every\r\ntime I aim to give it a shot, I wind up picking too big a challenge, where I\r\nshould be focusing the effort on learning the language. So, a nice toy example.\r\n\r\n## Development Environment\r\n\r\nOf course, I can't really get started without tooling up a bit. First of all,\r\nget Go installed on my (Mac) laptop with homebrew:\r\n\r\n```shell\r\nbrew install go\r\n```\r\n\r\nwhich has, between me playing yesterday and documenting it today, helpfully\r\nbeen updated to Go 1.1. So I'm going to have to re-figure what I've done to\r\nmake it work with 1.1! Which makes documenting where I started and how I got to\r\nhere a little tricky, so let's focus on how to get the environment up and\r\nrunning.\r\n\r\nThe `go` tool relies on a couple of environment variables to help it figure out\r\nwhere to find things and where to put things:\r\n\r\n* `GOROOT` which is the root of the Go installation. If you're using homebrew,\r\n  you can safely add `export GOROOT=\"$(brew --prefix go)\"` to your bash/zsh\r\n  profile and you're good to go.\r\n\r\n* `GOPATH` which points to your local Go workspace. This is much like a\r\n  workspace in Eclipse, as I understand it, in that it's one place to keep all\r\n  your source code and their dependencies. It may well be sensible to have a\r\n  workspace per project or per 'role', but for now I'm just dumping everything\r\n  into a single workspace, so I've added\r\n  `export GOPATH=\"${HOME}/Development/Go\"` to my `~/.zshenv` for now.\r\n\r\nSo, there we have it, a working Go environment. Wait, there's just one extra\r\nthing: editor support. I drink the vim koolaid, and there's a vim plugin\r\ndistributed with Go (if you've got the homebrew version installed, you'll find\r\nit at `/usr/local/opt/go/misc/vim`). Add that plugin to vim in your preferred\r\nmanner. I added a couple of extra files:\r\n\r\n* [`compiler/go.vim`](https://github.com/mathie/.vim/blob/master/compiler/go.vim)\r\n  which sets the correct `makeprg` and `errorformat` when editing go programs;\r\n  and\r\n\r\n* [`ftplugin/go/compiler.vim`](https://github.com/mathie/.vim/blob/master/ftplugin/go/compiler.vim)\r\n  which tells it to use the go compiler as defined above when editing go files.\r\n\r\nNow when I run `:make` et al in vim while editing a go file, it does some\r\napproximation of the right thing.\r\n\r\n## A note about workspaces\r\n\r\nI only discovered Go's workspaces this morning when I tried to build my code\r\nagainst the newly installed Go 1.1 and it didn't work. The setup and layout of\r\nworkspaces is covered in detail in\r\n[How to write Go code](http://golang.org/doc/code.html), so here's the short\r\nversion.\r\n\r\nThere are three directories inside your workspace:\r\n\r\n* `bin` where executable commands are placed after they've been built;\r\n\r\n* `pkg` where static libraries of your dependencies are placed after they've\r\n  been built; and\r\n\r\n* `src` which contains the source code to your application and its dependent\r\n  libraries (in other words, where all the action happens).\r\n\r\nI haven't played around with dependencies much yet, but it sounds like, while\r\nGo will happily download and install dependencies on your behalf, you don't\r\nhave much control over the upstream versions of these dependencies. So I'm\r\ngoing to revise my previous statement about workspace-per-whatever and say you\r\nshould have a workspace per project. That workspace should be version\r\ncontrolled, and the import of dependencies managed as you normally would\r\n(submodules, subtree merge, whatever).\r\n\r\nAnyway. If you're at the root of your workspace, you can pull in my attempt at\r\nthe TCP proxy with the following command:\r\n\r\n```shell\r\ngo get github.com/mathie/tcpip_proxy\r\n```\r\n\r\nwhich will download it, and place it in\r\n`${GOPATH}/src/github.com/mathie/tcpip_proxy`. You can then generate the binary\r\nwith:\r\n\r\n```shell\r\ngo install github.com/mathie/tcpip_proxy\r\n```\r\n\r\nThis will compile the source (and any dependencies if there were any) build the\r\nbinary and dump it in the `bin/` directory. You could run it as:\r\n\r\n```shell\r\nbin/tcpip_proxy\r\n```\r\n\r\nand it'll tell you how to get it running, but that's not terribly interesting.\r\nIt does roughly the same as the article at the start says.\r\n\r\nIf you're actively hacking on this particular module, Go's OK with that, too.\r\nInside your workspace, you can cd into the package and start editing from\r\nthere:\r\n\r\n```shell\r\ncd github.com/mathie/tcpip_proxy\r\n```\r\n\r\nThis time when you want to build the project, you can just do:\r\n\r\n```shell\r\ngo build\r\n```\r\n\r\nand it'll dump the resulting executable in your current directory (so you'll\r\nwant to gitignore that...). I believe that it will still resolve other\r\ndependencies from your workspace and the global go root.\r\n\r\n## What I actually did\r\n\r\nSo after all that. This was meant to be a 20 minute exercise, typing/copying\r\nthe code from the article to get a feel for it, running it and tweaking\r\nslightly. What it turned into was a day long excursion into the world of Go,\r\nattempting to refactor the program into a more sensible (to me) structure,\r\nwhile sticking with Go's idioms.\r\n\r\nMost of what I did was to break the code up into smaller functions, because\r\nthat's how I think. But I also tried to divide it into clumps of data and the\r\noperations performed on that data (which sounds an awful lot like objects).\r\nHere's the four objects I extracted:\r\n\r\n* [`Logger`](logger.go) which encapsulates the goroutine which takes log\r\n  messages and dumps them out to the appropriate log file.\r\n\r\n* [`Channel`](channel.go) which encapsulates a unidirectional channel between\r\n  two sockets, logging and forwarding packets, in another goroutine.\r\n\r\n* [`Connection`](connection.go) which combines two channels - one in each\r\n  direction - plus an overall logger for general connection information.\r\n\r\n* [`Proxy`](proxy.go) which listens for new connections, then kicks off a new\r\n  connection goroutine to handle each of them.\r\n\r\nThere's also the main program itself in [tcpip_proxy.go](tcpip_proxy.go) which\r\nparses command line arguments, then kicks off a `Proxy` to make it all work.\r\nIt's just wiring.\r\n\r\nInitially, I split off all these objects into separate packages, naming the\r\npackage after the single class inside, and following the convention for\r\nexported names. (The convention is that names beginning with an uppercase\r\nletter are exported from the package; those beginning with a lower case letter\r\naren't.) However, after switching to the workspace setup in Go 1.1, I've moved\r\nthem all back to a single package. I'm still a little unsure about what 'size'\r\na package should be, how granular things should be, what I should be exporting\r\nfrom packages and suchlike. Something I'm sure will start to gel as I write\r\nlarger code bases.\r\n\r\nSo, yes, most of what I learned was how to clump together related bits of data,\r\nand how to define behaviours on that data. In terms of the data, you define it\r\nby creating a type which is just a new label for any built in type. So if the\r\n'data' that you're operating on can be represented as a single string, you\r\ncould do:\r\n\r\n```go\r\ntype Hostname string\r\n```\r\n\r\nHowever, in my cases, I was wanting to clump together a few bits of data, so my\r\ntype would typically be a label for a struct:\r\n\r\n```go\r\ntype Proxy struct {\r\n  target           string\r\n  localPort        string\r\n  connectionNumber int\r\n}\r\n```\r\n\r\nIdiomatically, your package will have a constructor method to build a new one\r\nof these things (in this case, it's trivial):\r\n\r\n```go\r\nfunc NewProxy(targetHost, targetPort, localPort string) *Proxy {\r\n  target := net.JoinHostPort(targetHost, targetPort)\r\n\r\n  return &Proxy{\r\n    target:           target,\r\n    localPort:        localPort,\r\n    connectionNumber: connectionNumber,\r\n  }\r\n}\r\n```\r\n\r\n(I just discovered that if you're splitting a \"composite literal\" like that\r\nover several lines - say because you're writing documentation and want to keep\r\nthe line lengths short - then the final line must have a trailing `,` too. I\r\nalso discovered that error messages from the Go compiler are generally very\r\nhelpful.)\r\n\r\nThe [Effective Go](http://golang.org/doc/effective_go.html) documentation also\r\nsays that if the constructor is constructing something that's obvious from the\r\npackage name, just call it `New`.\r\n\r\nSo now we've got a clump of data and a means to build it. How to we define\r\nbehaviours for it? It took me about 3 reads of Effective Go to spot it, but\r\nthis is how you define these methods:\r\n\r\n```go\r\nfunc (proxy Proxy) Run() {\r\n  // Do stuff.\r\n}\r\n```\r\n\r\nI suppose I missed it because that looks a lot like defining return types in\r\nother languages. It's not, it's defining the type that the method operates on\r\nand giving it a name to access it inside the method. So, inside the method, the\r\nfields of the proxy struct are available as (e.g.) `proxy.target`, etc.\r\n\r\nCalling the method on the data is as you'd expect:\r\n\r\n```go\r\nproxy := NewProxy(\"localhost\", \"4000\", \"5000\")\r\nproxy.Run()\r\n```\r\n\r\nStraightforward enough. So that's data and their operations. Effective Go pays\r\na lot of attention to interfaces, which seem like a related topic, but I\r\ncouldn't see any way to apply them here, so I, well, haven't.\r\n\r\n## Packages\r\n\r\nAs I said above, I had split out all these objects into separate packages when\r\nI was working with Go 1.0.3 yesterday, but have coalesced it back into a single\r\npackage now. As far as I can tell, a package is one of two things:\r\n\r\n* A library which other code depends upon which, when installed will produce a\r\n  static library in `${GOPATH}/pkg`. In this case, start out each of your files\r\n  in the package with the 'short' package name (conventionally, the name of the\r\n  repo it sits in). So, if I was distributing this project as a library, I'd be\r\n  sticking `package tcpip_proxy` at the head of every file.\r\n\r\n* And if it's not a library, it's a program which installs a binary into\r\n  `${GOPATH}/bin`. In this case, start out each of the files in the package\r\n  with `package main`. This makes it a program. I haven't tried, but it seems\r\n  reasonable that you can have multiple programs (packages whose name is\r\n  `package main`) in a single workspace which are distinct instead by their\r\n  full import path.\r\n\r\nThe one thing I find odd about this: it doesn't seem possible to distribute a\r\nsingle package which can be both a library and a binary. Say, for example, I\r\nconsidered this project to be primarily a library, but I included a trivial\r\nbinary to demonstrate its use. I think I'd have to distribute the trivial\r\nbinary as a separate package. Something to investigate further another time.\r\n\r\n## Things I like about go\r\n\r\nI love working with goroutines and channels for passing messages between them.\r\nIt feels like a really natural way to think about software development. And, of\r\ncourse, it can allow the program to scale up onto multiple cores on your\r\ncomputer, run goroutines concurrently and get things done faster. I'm sure\r\nthere are still plenty of ways to trip myself up, but I managed to write a\r\ntrivial program that I observed running with 13 separate threads and not once\r\nhave to think about the complexities of concurrent programming. That's got to\r\nbe a win.\r\n\r\nI liked that the compiler makes me keep my imports in check, so that I can\r\nclearly see dependencies. The number of times I've looked at the myriad of\r\n`require 'foo'` lines in a ruby file that's been around for a few years and\r\nwondered if they're all necessary. Or, worse, with Rails' autoloader, not even\r\nknowing what a file's dependencies really are! This was particularly awesome as\r\nI split bits out into separate files.\r\n\r\nMultiple return values from a method. In particular, this comes into its own\r\nfor signalling errors. the typical idiom is to do something along the lines of:\r\n\r\n```go\r\nbytesRead, err := channel.Read(buffer)\r\nif err != nil {\r\n  panic(fmt.Sprintf(\"Channel read failed: %v\", err))\r\n}\r\n\r\n// Carry on\r\n```\r\n\r\nThis way we don't have to think of 'special' values of the return value\r\n(idiomatically -1 in C) to indicate errors, and then pass the actual error\r\nstatus out of band. I also like the pace of \"call a method, check for errors,\r\ncall a method, check for errors\". I always liked that style in C; apart from\r\nanything else, it's clear to see when errors are, and aren't, being checked\r\nwithout jumping out of the current context.\r\n\r\n`defer` is neat. It schedules a method to run at the end of the current scope,\r\nno matter how the current scope is exited. So far, most of what I've used it\r\nfor is to remember to close open files when I'm done with them - the same as\r\n  I'd do with blocks in Ruby. So, in Ruby:\r\n\r\n```ruby\r\ndef cracker\r\n  File.open('/etc/passwd') do |f|\r\n    # IN UR PASSWD FILE, CRACKIN UR PASSWDS\r\n  end\r\nend\r\n```\r\n\r\nwhich automatically closes the file at the end of the block. The equivalent in\r\nGo:\r\n\r\n```go\r\nfunc cracker() {\r\n  f, err := os.Open(\"/etc/passwd\")\r\n  // error checking elided...\r\n  defer f.Close()\r\n\r\n  // IN UR PASSWD FILE, CRACKIN UR PASSWDS\r\n}\r\n```\r\n\r\nThe Go version can be more flexible, because it allows the caller, rather than\r\nthe callee, to define the behaviour that happens at the end of the scope. And\r\nit avoids an extra level of indentation, which pleases me.\r\n\r\n## Conclusion\r\n\r\nI've run out of things to say. I've quite enjoyed this wee exercise.\r\nRefactoring existing code has been an excellent way to learn a bit more about\r\nGo - after all, by definition refactoring is not about introducing new\r\nbehaviour so I wasn't having to think about the problem domain. I could just\r\nfocus on finding out about bits of Go and use them to morph the program in some\r\nway.\r\n\r\nI'd be really interested in feedback. This is the first chunk of Go I've\r\nwritten. It was all written while staring at Effective Go, but I'm sure it's\r\nnot yet idiomatic Go. (I've seen code from experienced developers new to Ruby\r\nwriting idiomatically in their preferred language while using Ruby's keywords.\r\nI have no doubt that this code will smell of Ruby being written in Go syntax!)\r\n\r\nPull requests to turn it into idiomatic Go would be much appreciated.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
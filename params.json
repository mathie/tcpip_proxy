{"name":"TCP/IP Proxy in Go","tagline":"Learning Go one refactoring at a time","body":"# TCP/IP Proxy in Go\r\n\r\n**TL;DR: I took some existing code and refactored it to the way I'd structure it.\r\nHowever, this is the first chunk of Go I've ever touched. Please submit pull\r\nrequests to turn it into idiomatic Go!**\r\n\r\nFor some reason, I was reading\r\n[The Beauty of Concurrency in Go](http://pragprog.com/magazines/2012-06/the-beauty-of-concurrency-in-go)\r\nyesterday morning and decided to spend 20 minutes typing out the code to see\r\nhow it felt in reality. I've been meaning to try Go for a while now, but every\r\ntime I aim to give it a shot, I wind up picking too big a challenge, where I\r\nshould be focusing the effort on learning the language. So, a nice toy example.\r\n\r\n## Development Environment\r\n\r\nOf course, I can't really get started without tooling up a bit. First of all,\r\nget Go installed on my (Mac) laptop with homebrew:\r\n\r\n```shell\r\nbrew install go\r\n```\r\n\r\nwhich has, between me playing yesterday and documenting it today, helpfully\r\nbeen updated to Go 1.1. So I'm going to have to re-figure what I've done to\r\nmake it work with 1.1! Which makes documenting where I started and how I got to\r\nhere a little tricky, so let's focus on how to get the environment up and\r\nrunning.\r\n\r\nThe `go` tool relies on a couple of environment variables to help it figure out\r\nwhere to find things and where to put things:\r\n\r\n* `GOROOT` which is the root of the Go installation. If you're using homebrew,\r\n  you can safely add `export GOROOT=\"$(brew --prefix go)\"` to your bash/zsh\r\n  profile and you're good to go.\r\n\r\n* `GOPATH` which points to your local Go workspace. This is much like a\r\n  workspace in Eclipse, as I understand it, in that it's one place to keep all\r\n  your source code and their dependencies. It may well be sensible to have a\r\n  workspace per project or per 'role', but for now I'm just dumping everything\r\n  into a single workspace, so I've added\r\n  `export GOPATH=\"${HOME}/Development/Go\"` to my `~/.zshenv` for now.\r\n\r\nSo, there we have it, a working Go environment. Wait, there's just one extra\r\nthing: editor support. I drink the vim koolaid, and there's a vim plugin\r\ndistributed with Go (if you've got the homebrew version installed, you'll find\r\nit at `/usr/local/opt/go/misc/vim`). Add that plugin to vim in your preferred\r\nmanner. I added a couple of extra files:\r\n\r\n* [`compiler/go.vim`](https://github.com/mathie/.vim/blob/master/compiler/go.vim)\r\n  which sets the correct `makeprg` and `errorformat` when editing go programs;\r\n  and\r\n\r\n* [`ftplugin/go/compiler.vim`](https://github.com/mathie/.vim/blob/master/ftplugin/go/compiler.vim)\r\n  which tells it to use the go compiler as defined above when editing go files.\r\n\r\nNow when I run `:make` et al in vim while editing a go file, it does some\r\napproximation of the right thing.\r\n\r\n## A note about workspaces\r\n\r\nI only discovered Go's workspaces this morning when I tried to build my code\r\nagainst the newly installed Go 1.1 and it didn't work. The setup and layout of\r\nworkspaces is covered in detail in\r\n[How to write Go code](http://golang.org/doc/code.html), so here's the short\r\nversion.\r\n\r\nThere are three directories inside your workspace:\r\n\r\n* `bin` where executable commands are placed after they've been built;\r\n\r\n* `pkg` where static libraries of your dependencies are placed after they've\r\n  been built; and\r\n\r\n* `src` which contains the source code to your application and its dependent\r\n  libraries (in other words, where all the action happens).\r\n\r\nI haven't played around with dependencies much yet, but it sounds like, while\r\nGo will happily download and install dependencies on your behalf, you don't\r\nhave much control over the upstream versions of these dependencies. So I'm\r\ngoing to revise my previous statement about workspace-per-whatever and say you\r\nshould have a workspace per project. That workspace should be version\r\ncontrolled, and the import of dependencies managed as you normally would\r\n(submodules, subtree merge, whatever).\r\n\r\nAnyway. If you're at the root of your workspace, you can pull in my attempt at\r\nthe TCP proxy with the following command:\r\n\r\n```shell\r\ngo get github.com/mathie/tcpip_proxy\r\n```\r\n\r\nwhich will download it, and place it in\r\n`${GOPATH}/src/github.com/mathie/tcpip_proxy`. You can then generate the binary\r\nwith:\r\n\r\n```shell\r\ngo install github.com/mathie/tcpip_proxy\r\n```\r\n\r\nThis will compile the source (and any dependencies if there were any) build the\r\nbinary and dump it in the `bin/` directory. You could run it as:\r\n\r\n```shell\r\nbin/tcpip_proxy\r\n```\r\n\r\nand it'll tell you how to get it running, but that's not terribly interesting.\r\nIt does roughly the same as the article at the start says.\r\n\r\nIf you're actively hacking on this particular module, Go's OK with that, too.\r\nInside your workspace, you can cd into the package and start editing from\r\nthere:\r\n\r\n```shell\r\ncd github.com/mathie/tcpip_proxy\r\n```\r\n\r\nThis time when you want to build the project, you can just do:\r\n\r\n```shell\r\ngo build\r\n```\r\n\r\nand it'll dump the resulting executable in your current directory (so you'll\r\nwant to gitignore that...). I believe that it will still resolve other\r\ndependencies from your workspace and the global go root.\r\n\r\n## What I actually did\r\n\r\nSo after all that. This was meant to be a 20 minute exercise, typing/copying\r\nthe code from the article to get a feel for it, running it and tweaking\r\nslightly. What it turned into was a day long excursion into the world of Go,\r\nattempting to refactor the program into a more sensible (to me) structure,\r\nwhile sticking with Go's idioms.\r\n\r\nMost of what I did was to break the code up into smaller functions, because\r\nthat's how I think. But I also tried to divide it into clumps of data and the\r\noperations performed on that data (which sounds an awful lot like objects).\r\nHere's the four objects I extracted:\r\n\r\n* [`Logger`](logger.go) which encapsulates the goroutine which takes log\r\n  messages and dumps them out to the appropriate log file.\r\n\r\n* [`Channel`](channel.go) which encapsulates a unidirectional channel between\r\n  two sockets, logging and forwarding packets, in another goroutine.\r\n\r\n* [`Connection`](connection.go) which combines two channels - one in each\r\n  direction - plus an overall logger for general connection information.\r\n\r\n* [`Proxy`](proxy.go) which listens for new connections, then kicks off a new\r\n  connection goroutine to handle each of them.\r\n\r\nThere's also the main program itself in [tcpip_proxy.go](tcpip_proxy.go) which\r\nparses command line arguments, then kicks off a `Proxy` to make it all work.\r\nIt's just wiring.\r\n\r\nInitially, I split off all these objects into separate packages, naming the\r\npackage after the single class inside, and following the convention for\r\nexported names. (The convention is that names beginning with an uppercase\r\nletter are exported from the package; those beginning with a lower case letter\r\naren't.) However, after switching to the workspace setup in Go 1.1, I've moved\r\nthem all back to a single package. I'm still a little unsure about what 'size'\r\na package should be, how granular things should be, what I should be exporting\r\nfrom packages and suchlike. Something I'm sure will start to gel as I write\r\nlarger code bases.\r\n\r\nSo, yes, most of what I learned was how to clump together related bits of data,\r\nand how to define behaviours on that data. In terms of the data, you define it\r\nby creating a type which is just a new label for any built in type. So if the\r\n'data' that you're operating on can be represented as a single string, you\r\ncould do:\r\n\r\n```go\r\ntype Hostname string\r\n```\r\n\r\nHowever, in my cases, I was wanting to clump together a few bits of data, so my\r\ntype would typically be a label for a struct:\r\n\r\n```go\r\ntype Proxy struct {\r\n  target           string\r\n  localPort        string\r\n  connectionNumber int\r\n}\r\n```\r\n\r\nIdiomatically, your package will have a constructor method to build a new one\r\nof these things (in this case, it's trivial):\r\n\r\n```go\r\nfunc NewProxy(targetHost, targetPort, localPort string) *Proxy {\r\n  target := net.JoinHostPort(targetHost, targetPort)\r\n\r\n  return &Proxy{\r\n    target:           target,\r\n    localPort:        localPort,\r\n    connectionNumber: connectionNumber,\r\n  }\r\n}\r\n```\r\n\r\n(I just discovered that if you're splitting a \"composite literal\" like that\r\nover several lines - say because you're writing documentation and want to keep\r\nthe line lengths short - then the final line must have a trailing `,` too. I\r\nalso discovered that error messages from the Go compiler are generally very\r\nhelpful.)\r\n\r\nThe [Effective Go](http://golang.org/doc/effective_go.html) documentation also\r\nsays that if the constructor is constructing something that's obvious from the\r\npackage name, just call it `New`.\r\n\r\nSo now we've got a clump of data and a means to build it. How to we define\r\nbehaviours for it? It took me about 3 reads of Effective Go to spot it, but\r\nthis is how you define these methods:\r\n\r\n```go\r\nfunc (proxy Proxy) Run() {\r\n  // Do stuff.\r\n}\r\n```\r\n\r\nI suppose I missed it because that looks a lot like defining return types in\r\nother languages. It's not, it's defining the type that the method operates on\r\nand giving it a name to access it inside the method. So, inside the method, the\r\nfields of the proxy struct are available as (e.g.) `proxy.target`, etc.\r\n\r\nCalling the method on the data is as you'd expect:\r\n\r\n```go\r\nproxy := NewProxy(\"localhost\", \"4000\", \"5000\")\r\nproxy.Run()\r\n```\r\n\r\nStraightforward enough. So that's data and their operations. Effective Go pays\r\na lot of attention to interfaces, which seem like a related topic, but I\r\ncouldn't see any way to apply them here, so I, well, haven't.\r\n\r\n## Packages\r\n\r\nAs I said above, I had split out all these objects into separate packages when\r\nI was working with Go 1.0.3 yesterday, but have coalesced it back into a single\r\npackage now. As far as I can tell, a package is one of two things:\r\n\r\n* A library which other code depends upon which, when installed will produce a\r\n  static library in `${GOPATH}/pkg`. In this case, start out each of your files\r\n  in the package with the 'short' package name (conventionally, the name of the\r\n  repo it sits in). So, if I was distributing this project as a library, I'd be\r\n  sticking `package tcpip_proxy` at the head of every file.\r\n\r\n* And if it's not a library, it's a program which installs a binary into\r\n  `${GOPATH}/bin`. In this case, start out each of the files in the package\r\n  with `package main`. This makes it a program. I haven't tried, but it seems\r\n  reasonable that you can have multiple programs (packages whose name is\r\n  `package main`) in a single workspace which are distinct instead by their\r\n  full import path.\r\n\r\nThe one thing I find odd about this: it doesn't seem possible to distribute a\r\nsingle package which can be both a library and a binary. Say, for example, I\r\nconsidered this project to be primarily a library, but I included a trivial\r\nbinary to demonstrate its use. I think I'd have to distribute the trivial\r\nbinary as a separate package. Something to investigate further another time.\r\n\r\n## Testing\r\n\r\nTo round off my afternoon, I'm having a shot of the built in testing library\r\nfor Go, having noticed that the `go` tool has built in support for compiling\r\nand running tests. It's pretty straightforward: normally files with the\r\n`_test.go` suffix aren't compiled and linked into your build. However, if you\r\nrun:\r\n\r\n```shell\r\ngo test github.com/mathie/tcpip_proxy\r\n```\r\n\r\nfrom the root of your workspace, or just:\r\n\r\n```shell\r\ngo test\r\n```\r\n\r\nfrom the package itself, it builds a different binary (`tcpip_proxy.test`,\r\nwhich you'll probably want to gitignore, too) and runs it. This invokes the\r\ntest runner which runs all your tests and reports on the results, as you'd\r\nexpect.\r\n\r\nThe testing framework feels a little unusual to my xUnit (OK, latterly rspec)\r\neyes. There are three sorts of tests you can run: regular tests, benchmarks and\r\nexamples. The sort of test is reflected from the test method signature.\r\n\r\nExamples are fairly straightforward. These methods are of the form\r\n`func ExampleFooBar()`. You execute some code and provide a comment at the end\r\nof the method to describe the expected output on stdout. Useful for checking\r\nthe output of command line programs. For example:\r\n\r\n```go\r\nfunc ExampleOutput() {\r\n  fmt.Println(\"Hello, world\")\r\n\r\n  // Output:\r\n  // Hello, world\r\n}\r\n```\r\n\r\nFirst thing I jumped at to test was that my program was correctly generating\r\nsome help text to describe the command line arguments. This highlighted two\r\ninteresting problems:\r\n\r\n* It only appears to allow you to provide the output of `stdout` and\r\n  `flag.PrintDefaults()` (correctly) prints to `stderr`.\r\n\r\n* The test framework adds a bunch of extra flags to the running program anyway.\r\n\r\nSo I couldn't think up another useful example in this app...\r\n\r\nBenchmarks are really neat and I spent a little while playing around with how\r\nperformance changes by splitting a trivial example over a number of goroutines.\r\nBenchmark methods have the signature `func BenchmarkFooBar(b *testing.B)`.\r\nHaving failed to come up with a better example, I was inspired by the\r\ndocumentation to benchmark `fmt.Sprintf`:\r\n\r\n```go\r\nfunc DoSprintf(times int) {\r\n  for j := 0; j < times; j++ {\r\n    fmt.Sprintf(\"This benchmark will be run %d times.\\n\", times)\r\n  }\r\n}\r\n```\r\n\r\nand a wee wrapper to run it as a goroutine, signalling along a channel that it's done:\r\n\r\n```go\r\nfunc GoDoSprintf(times int, signal chan bool) {\r\n  go func(signal chan bool) {\r\n    DoSprintf(times)\r\n\r\n    signal <- true\r\n  }(signal)\r\n}\r\n```\r\n\r\nand finally a wrapper for that to 'split' the work amongst a number of\r\ngoroutines and wait for them all to signal that they've finished before\r\nreturning:\r\n\r\n```go\r\nfunc GoroutineSprintf(goRoutines, times int) {\r\n  signal := make(chan bool)\r\n  share := times / goRoutines\r\n\r\n  for i := 0; i < goRoutines; i++ {\r\n    GoDoSprintf(share, signal)\r\n  }\r\n\r\n  for i := 0; i < goRoutines; i ++ {\r\n    <- signal\r\n  }\r\n}\r\n```\r\n\r\nStraightforward enough. (Incidentally, I nicked the pattern for the goroutines\r\nto signal completion from the original program. I hope it's an idiomatic Go\r\npattern where it's needed; I think it's quite neat.) Now, a simple benchmark to\r\nget a baseline without using goroutines:\r\n\r\n```go\r\nfunc BenchmarkSprintf(b *testing.B) {\r\n  DoSprintf(b.N)\r\n}\r\n```\r\n\r\nand a benchmark running with various numbers of goroutines:\r\n\r\n```go\r\nfunc BenchmarkGoroutineSprintf2(b *testing.B) {\r\n  GoroutineSprintf(2, b.N)\r\n}\r\n```\r\n\r\nI have permutations for this for 2, 4, 8 and 16 goroutines. It's pretty neat.\r\nIt runs all your benchmarks, then reports on how long each operation takes\r\n(presumably total time / number of iterations). A few observations, though:\r\n\r\n* It only runs the benchmarks if you specify the `-bench` flag. So to get it to\r\n  run all your benchmarks, run `go test -bench .`.\r\n\r\n* Even if you do specify the `-bench` flag, it will not run your benchmarks if\r\n  you have any failing tests or examples, which it runs first. This makes\r\n  sense, I suppose, but tripped me up because my example file had examples of\r\n  failing tests, too!\r\n\r\n* At first glance, goroutines didn't seem to have much performance benefit at\r\n  all. Then I noticed the `-cpu` flag which specifies a list of `GOMAXPROCS`\r\n  (the number of simultaneously running goroutines) values for test runs. It\r\n  says this defaults to the 'current value of GOMAXPROCS' which in my case\r\n  appears to be 1. It accepts a list, so specifying `1,2,4,8` means it will run\r\n  each benchmark (and test/example too) with `GOMAXPROC` set to each of those\r\n  values. I started to see an improvement when it was `> 1`. :)\r\n\r\n* Not as much improvement as I'd have liked, though. It took a while to strike\r\n  me as to why. It turns out that Go attempts to run each benchmark for\r\n  approximately a fixed period of time (1 second by default, controlled by the\r\n  `-benchtime` argument). This means it will repeatedly call your benchmark\r\n  method, refining `b.N` each time so that the total runtime is about 1 second.\r\n  (You can see this by adding `fmt.Printf(\"Running DoSprintf(%d).\\n\", times)`\r\n  into the `DoSprintf` method.)\r\n\r\n  I can see why this is useful, but I would like to have fixed `b.N` here so\r\n  the benchmark was being called once, to see if the overhead of setting up the\r\n  goroutines and channels was affecting the overall performance.\r\n\r\nSo that's the benchmarks. How about regular, 'proper' tests? Well, they're\r\ncharacterised by the method signature `func TestFooBar(t *testing.T)` and\r\nthey're the ones that are a bit 'different' to me. There doesn't seem to be the\r\nusual xUnit pattern of having assertions. Instead, a test is considered to have\r\npassed if it runs to completion without being skipped or failed. So, here's a\r\npassing test:\r\n\r\n```go\r\nfunc TestPassingTest(t *testing.T) {\r\n  result := 1 + 1\r\n  fmt.Sprintf(\"1 + 1 = %d\\n\", result)\r\n}\r\n```\r\n\r\nNo assertions, nor a `should` in sight, just plain old code. That feels a bit\r\nodd. You can run tests with `go test` which will give you some terse output\r\nabout whether it passes or fails and a total runtime:\r\n\r\n```shell\r\n> go test\r\nPASS\r\nok      github.com/mathie/tcpip_proxy   0.018s\r\n```\r\n\r\nor you can pass in the `-v` flag to get verbose output:\r\n\r\n```shell\r\n> go test -v\r\n=== RUN TestPassingTest\r\n--- PASS: TestPassingTest (0.00 seconds)\r\nPASS\r\nok      github.com/mathie/tcpip_proxy   0.017s\r\n```\r\n\r\nSo, how do we mark a test that should be skipped (don't run the (remainder of)\r\nthe test and note that it was skipped in the verbose output)? Like this:\r\n\r\n```go\r\nfunc TestSkippedTest(t *testing.T) {\r\n  fmt.Println(\"This will be printed.\")\r\n  t.Skip(\"Skipping this test for now.\")\r\n  fmt.Println(\"This will not be printed.\")\r\n}\r\n```\r\n\r\nwhich verbosely outputs something like:\r\n\r\n```go\r\n=== RUN TestSkippedTest\r\nThis will be printed.\r\n--- SKIP: TestSkippedTest (0.00 seconds)\r\n        channel_test.go:15: Skipping this test for now.\r\nPASS\r\nok      github.com/mathie/tcpip_proxy   0.017s\r\n```\r\n\r\nAs you can see, skipped tests are considered to be passing (if you don't ask\r\nfor the verbose output, you'll get no notification that there are any skipped\r\ntests at all). So, how about failing tests?\r\n\r\n```go\r\nfunc TestImmediatelyFailingTest(t *testing.T) {\r\n  fmt.Println(\"This will be printed.\")\r\n  t.Fatal(\"This test will fail now and not run to completion\")\r\n  fmt.Println(\"This will not be printed.\")\r\n}\r\n```\r\n\r\nThe test will fail and will immediately terminate the test method (I wonder if\r\nit uses `panic` and `recover` under the covers? `defer` still works.) This\r\nseems like the natural behaviour, but there is an alternative:\r\n\r\n```go\r\nfunc TestFailingTest(t *testing.T) {\r\n  fmt.Println(\"This will be printed.\")\r\n  t.Error(\"This test will ultimately fail, but will continue to completion\")\r\n  fmt.Println(\"This will also be printed.\")\r\n}\r\n```\r\n\r\nwhich marks the test as failed, but still continues running it. I suppose that\r\nwould be useful if there's some state you need to restore after the test\r\nanyway, but that seems like a prime use of `defer`... Either way, the verbose\r\ntest output looks like:\r\n\r\n```shell\r\n=== RUN TestFailingTest\r\nThis will be printed.\r\nThis will also be printed.\r\n--- FAIL: TestFailingTest (0.00 seconds)\r\n        channel_test.go:21: This test will ultimately fail, but will continue to completion\r\n=== RUN TestImmediatelyFailingTest\r\nThis will be printed.\r\n--- FAIL: TestImmediatelyFailingTest (0.00 seconds)\r\n        channel_test.go:28: This test will fail now and not run to completion\r\nFAIL\r\nexit status 1\r\nFAIL    github.com/mathie/tcpip_proxy   0.018s\r\n```\r\n\r\nFair enough. I'll endeavour to continue mucking around with the test framework\r\nbut so far it's feeling a little \"low level\", like it's the tools that you'd\r\nuse to write a test framework rather than the framework you'd use. I suppose\r\neverybody's testing needs are different (cf the sheer number of testing\r\nframeworks in the Ruby community). I think I'd be happy with something along\r\nthe lines of the following:\r\n\r\n```go\r\nfunc setUp() {\r\n  fmt.Println(\"Shared test setup for this module.\")\r\n}\r\n\r\nfunc tearDown() {\r\n  fmt.Println(\"Shared test teardown for this module.\")\r\n}\r\n\r\nfunc assert(t *testing.T, value bool, message string) {\r\n  if !value {\r\n    t.Fatalf(\"Assertion failed: %v should have been true but was not: %v\", value, message)\r\n  }\r\n}\r\n\r\nfunc TestPassingTestWithAssert(t *testing.T) {\r\n  setUp()\r\n  defer tearDown()\r\n\r\n  assert(t, true, \"True is not true!\")\r\n}\r\n\r\nfunc TestFailingTestWithAssert(t *testing.T) {\r\n  setUp()\r\n  defer tearDown()\r\n\r\n  assert(t, false, \"False is not true!\")\r\n}\r\n```\r\n\r\nI wonder how easy it would be to tidy that up so `setU()` and `tearDown()` were\r\nautomatically called if defined, and I could avoid having to pass\r\n`t *testing.T` into each `assert`...\r\n\r\n## Formatting Code\r\n\r\n`go fmt` automatically formats your code in the proscribed Go style. And there\r\nis a single proscribed Go style, so you can be reasonably sure that any random\r\ncode you pick up that's written in Go is within a command of looking the same.\r\nIt also helps that apparently we largely agree on said style anyway. After two\r\ndays of hacking with the code, the only things it picked me up on where:\r\n\r\n* Tabs, not spaces. OK, I can live with that one. My position on the tabs vs\r\n  spaces debate is \"not both\".\r\n\r\n* Imports should be in alphabetical order. Good call again, I was mostly being\r\n  lazy. It's good to note then that the ordering plain isn't important to the\r\n  compiler, which beats `#include` ordering games...\r\n\r\n* No spacing out string concatenation. So when I write out\r\n  `\"[\" + timestamp() + \"]\"`, it takes out the spaces. Less enthusiastic about\r\n  this one (I like my horizontal space) but OK.\r\n\r\n* Vertically aligning types in struct definitions, composite literals, etc.\r\n  Yeah, I normally do that too, I just forgot that one time, OK?\r\n\r\n* Not vertically aligning successive assignments. You liked me vertically\r\n  aligning other things, I wonder if this is an oversight?\r\n\r\n## Things I like about go\r\n\r\nI love working with goroutines and channels for passing messages between them.\r\nIt feels like a really natural way to think about software development. And, of\r\ncourse, it can allow the program to scale up onto multiple cores on your\r\ncomputer, run goroutines concurrently and get things done faster. I'm sure\r\nthere are still plenty of ways to trip myself up, but I managed to write a\r\ntrivial program that I observed running with 13 separate threads and not once\r\nhave to think about the complexities of concurrent programming. That's got to\r\nbe a win.\r\n\r\nI liked that the compiler makes me keep my imports in check, so that I can\r\nclearly see dependencies. The number of times I've looked at the myriad of\r\n`require 'foo'` lines in a ruby file that's been around for a few years and\r\nwondered if they're all necessary. Or, worse, with Rails' autoloader, not even\r\nknowing what a file's dependencies really are! This was particularly awesome as\r\nI split bits out into separate files.\r\n\r\nMultiple return values from a method. In particular, this comes into its own\r\nfor signalling errors. the typical idiom is to do something along the lines of:\r\n\r\n```go\r\nbytesRead, err := channel.Read(buffer)\r\nif err != nil {\r\n  panic(fmt.Sprintf(\"Channel read failed: %v\", err))\r\n}\r\n\r\n// Carry on\r\n```\r\n\r\nThis way we don't have to think of 'special' values of the return value\r\n(idiomatically -1 in C) to indicate errors, and then pass the actual error\r\nstatus out of band. I also like the pace of \"call a method, check for errors,\r\ncall a method, check for errors\". I always liked that style in C; apart from\r\nanything else, it's clear to see when errors are, and aren't, being checked\r\nwithout jumping out of the current context.\r\n\r\n`defer` is neat. It schedules a method to run at the end of the current scope,\r\nno matter how the current scope is exited. So far, most of what I've used it\r\nfor is to remember to close open files when I'm done with them - the same as\r\n  I'd do with blocks in Ruby. So, in Ruby:\r\n\r\n```ruby\r\ndef cracker\r\n  File.open('/etc/passwd') do |f|\r\n    # IN UR PASSWD FILE, CRACKIN UR PASSWDS\r\n  end\r\nend\r\n```\r\n\r\nwhich automatically closes the file at the end of the block. The equivalent in\r\nGo:\r\n\r\n```go\r\nfunc cracker() {\r\n  f, err := os.Open(\"/etc/passwd\")\r\n  // error checking elided...\r\n  defer f.Close()\r\n\r\n  // IN UR PASSWD FILE, CRACKIN UR PASSWDS\r\n}\r\n```\r\n\r\nThe Go version can be more flexible, because it allows the caller, rather than\r\nthe callee, to define the behaviour that happens at the end of the scope. And\r\nit avoids an extra level of indentation, which pleases me.\r\n\r\nDespite its unusual (to me) behaviour, I'm getting on rather well with the test\r\nsuite. We're definitely going to spend some more time together. Although it\r\nmight be time spent ... enhancing it the way I'd like to use it. :)\r\n\r\n## Conclusion\r\n\r\nI've run out of things to say. I've quite enjoyed this wee exercise.\r\nRefactoring existing code has been an excellent way to learn a bit more about\r\nGo - after all, by definition refactoring is not about introducing new\r\nbehaviour so I wasn't having to think about the problem domain. I could just\r\nfocus on finding out about bits of Go and use them to morph the program in some\r\nway.\r\n\r\nI'd be really interested in feedback. This is the first chunk of Go I've\r\nwritten. It was all written while staring at Effective Go, but I'm sure it's\r\nnot yet idiomatic Go. (I've seen code from experienced developers new to Ruby\r\nwriting idiomatically in their preferred language while using Ruby's keywords.\r\nI have no doubt that this code will smell of Ruby being written in Go syntax!)\r\n\r\nPull requests to turn it into idiomatic Go would be much appreciated.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}